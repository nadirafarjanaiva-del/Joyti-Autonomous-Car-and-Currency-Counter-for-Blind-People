from gpiozero import Motor, PWMOutputDevice  
from picamera2 import Picamera2
import cv2
import numpy as np
import time
from ultralytics import YOLO

# ---------------------------
# Motor setup
# ---------------------------
right_motor = Motor(forward=5, backward=23)
left_motor = Motor(forward=24, backward=27)

right_speed = PWMOutputDevice(13)
left_speed = PWMOutputDevice(12)

# ---------------------------
# Camera setup
# ---------------------------
picam2 = Picamera2()
picam2.configure(picam2.create_preview_configuration(main={"size": (720, 560)}))
picam2.start()
picam2.set_controls({"FrameRate": 30})

# ---------------------------
# YOLOv8 setup
# ---------------------------
model = YOLO("yolov8n.pt")  # lightweight model for Pi

# ---------------------------
# Perspective transform setup
# ---------------------------
# Perspective transform points
source_points = np.float32([[5, 480], [760, 480], [55, 250], [685, 250]])
destination_points = np.float32([ [100, 240], [280, 240], [100, 0], [280, 0]])

def perspective_transform(frame):
    matrix = cv2.getPerspectiveTransform(source_points, destination_points)
    return cv2.warpPerspective(frame, matrix, (400, 240))
def process_frame(frame):
    frame_gray = cv2.cvtColor(frame, cv2.COLOR_RGB2GRAY)
    frame_thresh = cv2.inRange(frame_gray, 235, 255)
    frame_edge = cv2.Canny(frame_thresh, 400, 600, 3)
    frame_final = cv2.bitwise_or(frame_thresh, frame_edge)
    return cv2.cvtColor(frame_final, cv2.COLOR_GRAY2RGB)

def compute_histogram(frame_final):
    histogram_lane = np.zeros(400)
    for i in range(400):
        roi_lane = frame_final[140:240, i:i+1]
        histogram_lane[i] = np.sum(roi_lane) / 255
    return histogram_lane

def compute_histogram_laneEnd(frame_final1):
    histogram_laneEnd = np.zeros(400)
    for i in range(400): 
        roi_laneEnd = frame_final1[0:240, i:i+1]
        histogram_laneEnd[i] = np.sum(roi_laneEnd) / 255
    return np.sum(histogram_laneEnd)

def lane_detection(histogram_lane):
    left_lane_pos = np.argmax(histogram_lane[:150])
    right_lane_pos = np.argmax(histogram_lane[250:]) + 250
    return left_lane_pos, right_lane_pos

# ---------------------------
# Distance estimation
# ---------------------------
def estimate_distance(bbox_width_px, focal_length_px=1280, known_width_cm=6):
    if bbox_width_px <= 0:
        return None
    return (known_width_cm * focal_length_px) / bbox_width_px

# ---------------------------
# Motor controls
# ---------------------------
def move_forward():
    left_motor.forward(); right_motor.forward()
    left_speed.value = 0.25; right_speed.value = 0.25

def stop_motors():
    left_motor.stop(); right_motor.stop()
    left_speed.value = 0; right_speed.value = 0

def turn_left_1():
    left_motor.backward(); right_motor.forward()
    left_speed.value = 0.1; right_speed.value = 0.25

def turn_left_2():
    left_motor.backward(); right_motor.forward()
    left_speed.value = 0.15; right_speed.value = 0.25

def turn_left_3():
    left_motor.backward(); right_motor.forward()
    left_speed.value = 0.25; right_speed.value = 0.25

def turn_right_1():
    left_motor.forward(); right_motor.backward()
    left_speed.value = 0.25; right_speed.value = 0.1

def turn_right_2():
    left_motor.forward(); right_motor.backward()
    left_speed.value = 0.25; right_speed.value = 0.15

def turn_right_3():
    left_motor.forward(); right_motor.backward()
    left_speed.value = 0.25; right_speed.value = 0.25

def Uturn_Right():
    left_motor.forward(); right_motor.backward()
    left_speed.value = 0.2; right_speed.value = 0.1
    time.sleep(2.0)

# ---------------------------
# Main loop
# ---------------------------
try:
    while True:
        frame = picam2.capture_array()
        if frame is None:
            continue

        # Convert 4-channel (XBGR) to 3-channel BGR for YOLO
        frame_bgr = cv2.cvtColor(frame, cv2.COLOR_RGBA2BGR)

        # ---------------------------
        # Lane processing
        # ---------------------------
        for i in range(4):
            cv2.line(frame, tuple(map(int, source_points[i])),
                     tuple(map(int, source_points[(i+1)%4])),
                     (255, 0, 0), 2)

        frame_perspective = perspective_transform(frame)
        frame_final = process_frame(frame_perspective)
        frame_final1 = frame_final.copy()
        histogram_lane = compute_histogram(frame_final)
        left_lane_pos, right_lane_pos = lane_detection(histogram_lane)
        LaneEnd = compute_histogram_laneEnd(frame_final1)

        if LaneEnd > 33000:
            Uturn_Right()
        elif left_lane_pos > 0 and right_lane_pos > 0:
            lane_center = (right_lane_pos - left_lane_pos) // 2 + left_lane_pos
            frame_center = 188
            result = (lane_center - frame_center) // 4
        else:
            result = 0
        print(f"Reuslt {result}")

        # ---------------------------
        # YOLO Stop Sign Detection (no confidence threshold)
        # ---------------------------
        results = model.predict(frame_bgr, classes=[11], verbose=False)  # if class 11 = stop sign
        annotated_frame = results[0].plot()

        stop_detected = False
        for box in results[0].boxes:
            cls_id = int(box.cls[0])
            label = model.names[cls_id].lower()
            if "stop" in label:
                x1, y1, x2, y2 = map(float, box.xyxy[0])
                bbox_width = x2 - x1
                distance_cm = estimate_distance(bbox_width, known_width_cm=6)
                if distance_cm and distance_cm <= 50:
                    stop_detected = True
                    stop_motors()
                    cv2.putText(annotated_frame, "STOPPED for 5s", (int(x1), int(y1)+100),
                                cv2.FONT_HERSHEY_SIMPLEX, 0.8, (0, 0, 255), 2)
                    cv2.imshow("Detection Window", annotated_frame)
                    cv2.waitKey(1)
                    time.sleep(5)
                    move_forward()
                    break

        # ---------------------------
        # Lane motor control (skip if stop detected)
        # ---------------------------
        if not stop_detected:
            if result == 0:
                move_forward()
            elif 0 < result < 3:
                turn_right_1()
            elif 3 <= result < 5:
                turn_right_2()
            elif result >= 5:
                turn_right_3()
            elif result < 0 and result > -3:
                turn_left_1()
            elif -3 >= result > -5:
                turn_left_2()
            elif result <= -5:
                turn_left_3()

        # ---------------------------
        # Visualization
        # ---------------------------
        cv2.line(frame_final, (left_lane_pos, 0), (left_lane_pos, 240), (0, 255, 0), 2)
        cv2.line(frame_final, (right_lane_pos, 0), (right_lane_pos, 240), (0, 255, 0), 2)
        cv2.line(frame_final, (188, 0), (188, 240), (255, 0, 0), 2)

        cv2.putText(frame_perspective, "Perspective Transform", (10, 30),
                    cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255, 255, 0), 2)
        cv2.putText(frame_final, f"Final Frame Result: {result}", (10, 30),
                    cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255, 0, 0), 2)

        cv2.imshow("Perspective", frame_perspective)
        cv2.imshow("Final", frame_final)
        cv2.imshow("Detection Window", annotated_frame)

        if cv2.waitKey(1) & 0xFF == ord('q'):
            stop_motors()
            break

finally:
    stop_motors()
    picam2.stop()
    cv2.destroyAllWindows()
